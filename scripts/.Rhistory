"IGFBP1" %in% annotation$`Gene name`
plot_counts <- function (dds, gene, normalization = "DESeq2"){
annotation <- fread("data/GRCh38.p14_annotation.csv", header = T, stringsAsFactors = F)
if (normalization == "cpm") {
normalized_data <- cpm(counts(dds, normalized = F))
} else if (normalization == "DESeq2")
normalized_data <- counts(dds, normalized = T)
condition <- dds@colData$condition
if (is.numeric(gene)) {
if (gene%%1==0 )
ensembl_id <- rownames(normalized_data)[gene]
else
stop("Invalid index supplied.")
} else if (gene %in% annotation$`Gene name`){
ensembl_id <- annotation$Geneid[which(annotation$`Gene name` == gene)]
} else if (gene %in% annotation$`Gene stable ID`){
ensembl_id <- gene
} else {
stop("Gene not found. Check spelling.")
}
expression <- normalized_data[1,]
gene_name <- annotation$Genesymbol[which(annotation$`Gene stable ID` == ensembl_id)]
gene_tib <- tibble(condition = condition, expression = expression)
ggplot(gene_tib, aes(x = condition, y = expression))+
geom_boxplot(outlier.size = NULL)+
geom_point()+
labs (title = paste0("Expression of ", gene_name, " - ", ensembl_id), x = "group", y = paste0("Normalized expression (", normalization , ")"))+
theme(axis.text.x = element_text(size = 11), axis.text.y = element_text(size = 11))
}
gene_plot<-plot_counts(dds, "IGFBP1")
ggsave(filename ="results/IGFBP1_cond.png" , plot = gene_plot,bg = "white", width = 8, height = 6, dpi = 300)
head(res_lncap)
# Map Ensembl IDs to gene symbols using org.Hs.eg.db
symbol_map <- bitr(res_lncap$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
# Merge and filter
rank_df <- merge(res_lncap, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df <- rank_df[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df) <- c("Gene.name", "log2FoldChange")
# Save as .rnk
head(rank_df)
write.table(rank_df, file = "data/lncaprank.rnk", sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
prepare_ranked_list <- function(ranked_list) {
#check if nammed numeric vector
if (is.vector(ranked_list) && !is.list(ranked_list)) {
return(ranked_list)  # Return as-is if already processed
}
#check for requiered columns
if (!is.data.frame(ranked_list)) {
stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
}
#Check duplicate genes and avg. fold change
if (sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])
return(ranked_list)
}
#check if rank list exists
if (!exists("data/lncap_ranked_list")) {
#Convert res_lncap to a ranked list data
lncap_ranked_list <- as.data.frame(res_lncap) %>%
dplyr::select(Gene.name = gene_symbol, log2FoldChange)  # Adjust column names as needed
}
head(res_lncap)
annotation <- fread("data/GRCh38.p14_annotation.csv",stringsAsFactors = FALSE)
#renaming colnames
names(annotation)[names(annotation) %in% c("Gene stable ID", "Gene type", "Gene name")] <- c("Geneid", "Genebiotype", "Genesymbol")
library(tibble)
plot_counts <- function (dds, gene, normalization = "DESeq2"){
if (normalization == "cpm") {
normalized_data <- cpm(counts(dds, normalized = F))
} else if (normalization == "DESeq2")
normalized_data <- counts(dds, normalized = T)
condition <- dds@colData$condition
if (is.numeric(gene)) {
if (gene%%1==0 )
ensembl_id <- rownames(normalized_data)[gene]
else
stop("Invalid index supplied.")
} else if (gene %in% annotation$Genesymbol){
ensembl_id <- annotation$Geneid[which(annotation$Genesymbol == gene)]
} else if (gene %in% annotation$Geneid){
ensembl_id <- gene
} else {
stop("Gene not found. Check spelling.")
}
expression <- normalized_data[ensembl_id,]
gene_name <- annotation$Genesymbol[which(annotation$Geneid == ensembl_id)]
gene_tib <- tibble(condition = condition, expression = expression)
ggplot(gene_tib, aes(x = condition, y = expression))+
geom_boxplot(outlier.size = NULL)+
geom_point()+
labs (title = paste0("Expression of ", gene_name, " - ", ensembl_id), x = "group", y = paste0("Normalized expression (", normalization , ")"))+
theme(axis.text.x = element_text(size = 11), axis.text.y = element_text(size = 11))
}
gene_plot<-plot_counts(dds, "IGFBP1")
ggsave(filename ="results/IGFBP1_cond.png" , plot = gene_plot,bg = "white", width = 8, height = 6, dpi = 300)
# Filter the DESeq2 dataset (dds) to keep only LNCAP samples
dds_lncap <- dds[, grepl("LNCAP", colnames(dds))]
dds_lncap
dds_lncap$condition <- droplevels(dds_lncap$condition)#removing unrelated levels
#setting LNCAP Normoxia as reference
dds_lncap$condition <- relevel(dds_lncap$condition, ref = "LNCAP_Normoxia")
dds_lncap <- DESeq(dds_lncap)
# Extract differential expression results for contrast: LNCAP_Hypoxia vs LNCAP_Normoxia
res_lncap <- results(dds_lncap, contrast = c("condition", "LNCAP_Hypoxia", "LNCAP_Normoxia"))
res_lncap
summary(res_lncap)
reslncapOrdered <- res_lncap[order(res_lncap$padj), ] #order with padj values
sum(reslncapOrdered$padj < 0.05, na.rm = TRUE)
head(reslncapOrdered)
summary(reslncapOrdered)
write.csv(as.data.frame(reslncapOrdered), file = "data/DEGs_lncap.csv")
res_lncap <- read.csv("data/DEGs_lncap.csv", row.names = 1)
head(res_lncap)
library(clusterProfiler)
library(org.Hs.eg.db)
library(dplyr)
library(stats)
#convert ENSEMBL ids to entrez ids for Reactome
ncbi_list <- clusterProfiler::bitr(
geneID = rownames(res_lncap),        # use Ensembl IDs from row names
fromType = "ENSEMBL",
toType = "ENTREZID",
OrgDb = org.Hs.eg.db
)
#Column with Esemble ids
res_lncap$ENSEMBL <- rownames(res_lncap)
head(res_lncap)
#Merge ncbi_list with valid entrez id and remove duplicates
res_mapped <- res_lncap %>%
left_join(ncbi_list, by = "ENSEMBL") %>%
filter(!is.na(ENTREZID)) %>%
distinct(ENTREZID, .keep_all = TRUE)
#Genes ranked based on log2FoldChange
ngenes <- res_mapped$log2FoldChange
names(ngenes) <- res_mapped$ENTREZID
ngenes <- sort(ngenes, decreasing = TRUE)
#GSEA
library(ReactomePA)
enp_gsea <- gsePathway(
ngenes,
organism = "human",
#pvalueCutoff = 0.05,
#pAdjustMethod = "BH",
#minGSSize = 10,
#maxGSSize = 500,
verbose = FALSE
)
head(enp_gsea@result)
head(res_lncap)
# Map Ensembl IDs to gene symbols using org.Hs.eg.db
symbol_map <- bitr(res_lncap$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
# Merge and filter
rank_df <- merge(res_lncap, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df <- rank_df[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df) <- c("Gene.name", "log2FoldChange")
# Save as .rnk
head(rank_df)
write.table(rank_df, file = "data/lncaprank.rnk", sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
library(fgsea)
# Load Hallmark gene sets from GMT file
hallmark_pathway <- gmtPathways("data/h.all.v2025.1.Hs.symbols.gmt")
head(names(hallmark_pathway))
head(hallmark_pathway$HALLMARK_HYPOXIA, 20)
lncap_ranked_list <- read.table("data/lncaprank.rnk", header = T, stringsAsFactors = F)
head(lncap_ranked_list)
#Clean and prepare ranked list for fgsea
prepare_ranked_list <- function(ranked_list) {
if( sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(.~Gene.name, FUN = mean, data = ranked_list)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = T),]
}
# Remove NA values
ranked_list <- na.omit(ranked_list)
#Convert data frame to name vector
ranked_list <- tibble::deframe(ranked_list)
ranked_list
}
lncap_ranked_list <- prepare_ranked_list(lncap_ranked_list)
head(lncap_ranked_list)
prepare_ranked_list <- function(ranked_list) {
#check if nammed numeric vector
if (is.vector(ranked_list) && !is.list(ranked_list)) {
return(ranked_list)  # Return as-is if already processed
}
#check for requiered columns
if (!is.data.frame(ranked_list)) {
stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
}
#Check duplicate genes and avg. fold change
if (sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])
return(ranked_list)
}
#check if rank list exists
if (!exists("data/lncap_ranked_list")) {
#Convert res_lncap to a ranked list data
lncap_ranked_list <- as.data.frame(res_lncap) %>%
dplyr::select(Gene.name = gene_symbol, log2FoldChange)  # Adjust column names as needed
}
prepare_ranked_list <- function(ranked_list) {
#check if nammed numeric vector
if (is.vector(ranked_list) && !is.list(ranked_list)) {
return(ranked_list)  # Return as-is if already processed
}
#check for requiered columns
if (!is.data.frame(ranked_list)) {
stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
}
#Check duplicate genes and avg. fold change
if (sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])
return(ranked_list)
}
#check if rank list exists
if (!exists("data/lncap_ranked_list")) {
#Convert res_lncap to a ranked list data
symbol_map <- bitr(res_lncap$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
rank_df <- merge(res_lncap, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df <- rank_df[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df) <- c("Gene.name", "log2FoldChange")
lncap_ranked_list <- as.data.frame(res_lncap) %>%
dplyr::select(Gene.name = gene_symbol, log2FoldChange)  # Adjust column names as needed
}
prepare_ranked_list <- function(ranked_list) {
#check if nammed numeric vector
if (is.vector(ranked_list) && !is.list(ranked_list)) {
return(ranked_list)  # Return as-is if already processed
}
#check for requiered columns
if (!is.data.frame(ranked_list)) {
stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
}
#Check duplicate genes and avg. fold change
if (sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])
return(ranked_list)
}
#check if rank list exists
if (!exists("data/lncap_ranked_list")) {
#Convert res_lncap to a ranked list data
symbol_map <- bitr(res_lncap$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
rank_df <- merge(res_lncap, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df <- rank_df[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df) <- c("Gene.name", "log2FoldChange")
lncap_ranked_list <- rank_df
}
lncap_ranked_list <- prepare_ranked_list(lncap_ranked_list)
print(head(lncap_ranked_list))
fgsea_results <- fgsea(pathways = hallmark_pathway,
stats = lncap_ranked_list,
minSize = 15,
maxSize = 500,
nperm= 1000)
#Sort by decreasing NES
fgsea_results_ordered <- fgsea_results[order(-NES)]
head(fgsea_results_ordered[, .(pathway, padj, NES)])
#install.packages("waterfalls")
library(waterfalls)
waterfall_plot <- function (fsgea_results, graph_title) {
fgsea_results %>%
mutate(short_name = str_split_fixed(pathway, "_",2)[,2])%>% # removes 'HALLMARK_' from the pathway title
ggplot( aes(reorder(short_name,NES), NES)) +
geom_bar(stat= "identity", aes(fill = padj<0.05))+
coord_flip()+
labs(x = "Hallmark Pathway", y = "Normalized Enrichment Score", title = graph_title)+
theme(axis.text.y = element_text(size = 7),
plot.title = element_text(hjust = 1))
}
library(stringr)
hallmark_enrich<- waterfall_plot(fgsea_results, "Hallmark pathways altered by hypoxia in LNCaP cells")
ggsave("results/hallmark_enrich_lncap.png",
plot = hallmark_enrich,
bg = "white",
width = 10, height = 10, dpi = 300)
# Filter the DESeq2 dataset (dds) to keep only LNCAP samples
dds_pc3 <- dds[, grepl("PC3", colnames(dds))]
dds_pc3
dds_pc3$condition <- droplevels(dds_pc3$condition)#removing unrelated levels
#setting PC3 Normoxia as reference
dds_pc3$condition <- relevel(dds_pc3$condition, ref = "PC3_Normoxia")
dds_pc3 <- DESeq(dds_pc3)
# Extract differential expression results for contrast: LNCAP_Hypoxia vs LNCAP_Normoxia
res_pc3 <- results(dds_pc3, contrast = c("condition", "PC3_Hypoxia", "PC3_Normoxia"))
res_pc3
summary(res_pc3)
respc3Ordered <- res_pc3[order(res_pc3$padj), ] #order with padj values
sum(respc3Ordered$padj < 0.05, na.rm = TRUE)
head(respc3Ordered)
summary(respc3Ordered)
write.csv(as.data.frame(respc3Ordered), file = "data/DEGs_pc3.csv")
#install.packages("ggplot2")
library(ggplot2)
res_df <- as.data.frame(respc3Ordered)
res_df <- na.omit(res_df)
res_df$gene <- rownames(res_df) #gene names added as column
#Gene regulation categorised
res_df$regulation <- "Not Significant" #defaulted
res_df$regulation[res_df$padj < 0.05 & res_df$log2FoldChange > 1] <- "Upregulated"
res_df$regulation[res_df$padj < 0.05 & res_df$log2FoldChange < -1] <- "Downregulated"
#Volcano plot
qp <- ggplot(res_df, aes(x = log2FoldChange,
y = -log10(padj),
color = regulation)) + #categorise based on regulation
geom_point(alpha = 0.6) +
scale_color_manual(values = c("Upregulated" = "#FEA405",
"Downregulated" = "purple",
"Not Significant" = "gray")) +
#Threshold line at padj = 0.05
geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
#placement of text
annotate("text", x = min(res_df$log2FoldChange), y = -log2(0.05) + 0.5,
label = "padj = 0.05", hjust = 0, size = 3) +
theme_minimal() +
#labels
labs(title = "Volcano Plot",
x = "Log2 Fold Change",
y = "-Log10 Adjusted P-Value") +
theme(plot.title = element_text(hjust = 0.5))
v_plot <- "results/vp_pc3.png"
ggsave(v_plot, plot = qp,bg = "white", width = 8, height = 6, dpi = 300)
qp
res_pc3 <- read.csv("DEGs_pc3.csv", row.names = 1)
res_pc3 <- read.csv("data/DEGs_pc3.csv", row.names = 1)
head(res_pc3)
library(clusterProfiler)
library(org.Hs.eg.db)
library(dplyr)
library(stats)
#convert ENSEMBL ids to entrez ids for Reactome
ncbi_list <- clusterProfiler::bitr(
geneID = rownames(res_pc3),        # use Ensembl IDs from row names
fromType = "ENSEMBL",
toType = "ENTREZID",
OrgDb = org.Hs.eg.db
)
#Column with Esemble ids
res_pc3$ENSEMBL <- rownames(res_pc3)
head(res_pc3)
#Merge ncbi_list with valid entrez id and remove duplicates
res_mapped <- res_pc3 %>%
left_join(ncbi_list, by = "ENSEMBL") %>%
filter(!is.na(ENTREZID)) %>%
distinct(ENTREZID, .keep_all = TRUE)
#Genes ranked based on log2FoldChange
ngenes <- res_mapped$log2FoldChange
names(ngenes) <- res_mapped$ENTREZID
ngenes <- sort(ngenes, decreasing = TRUE)
#GSEA
library(ReactomePA)
enp_gsea <- gsePathway(
ngenes,
organism = "human",
#pvalueCutoff = 0.05,
#pAdjustMethod = "BH",
#minGSSize = 10,
#maxGSSize = 500,
verbose = FALSE
)
head(enp_gsea@result)
pathways <- enp_gsea@result
pathways <- pathways[order(pathways$p.adjust), ]# Sort by FDR (adjusted p-value)
top_pathways <- pathways[order(abs(pathways$NES), decreasing = TRUE), ]  # Sort by NES
library(dplyr)
library(forcats)
top20 <- top_pathways[1:20, ] %>%
mutate(Description = fct_reorder(Description, NES))  # Reorder factor for y-axis
write.csv(top20, "data/top20_pathways_pc3.csv", row.names = FALSE)
library(ggplot2)
enrich_overall <- ggplot(top20, aes(x = NES,
y = Description,
color = p.adjust,
size = setSize)) +
geom_point(alpha = 0.9) +
scale_color_gradient(low = "#0072B2", high = "#D55E00", name = "FDR (p.adjust)") +
scale_size(range = c(3, 10), name = "Gene Set Size") +
labs(
title = "Top 10 Enriched Pathways",
subtitle = "Gene Set Enrichment Analysis (GSEA)",
x = "Normalized Enrichment Score (NES)",
y = NULL,
caption = "Data source: clusterProfiler::gsePathway"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.y = element_text(size = 12),
axis.text.x = element_text(size = 12),
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 13),
legend.position = "right"
)
ggsave("results/enrichment_overall_pc3.png",
plot = enrich_overall,
bg = "white",
width = 15, height = 6, dpi = 300)
library(ReactomePA)
sig_genes <- res_mapped %>%
filter(padj < 0.1, abs(log2FoldChange) > 0.5) %>%
pull(ENTREZID)
enr <- enrichPathway(gene = sig_genes, organism = "human", pvalueCutoff = 0.1)
reactome_plot<- dotplot(enr, showCategory=20)
ggsave("results/react_sig_genes_pc3.png",
plot = reactome_plot,
bg = "white",
width = 8, height = 10, dpi = 300)
head(res_pc3)
symbol_map <- bitr(res_pc3$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
# Merge and filter
rank_df_pc3 <- merge(res_pc3, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df_pc3 <- rank_df_pc3[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df_pc3) <- c("Gene.name", "log2FoldChange")
# Save as .rnk
head(rank_df_pc3)
write.table(rank_df_pc3, file = "data/pc3rank.rnk", sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
View(rank_df)
View(rank_df_pc3)
View(rank_df)
View(rank_df_pc3)
View(rank_df)
library(fgsea)
hallmark_pathway <- gmtPathways("data/h.all.v2025.1.Hs.symbols.gmt")
head(names(hallmark_pathway))
head(hallmark_pathway$HALLMARK_HYPOXIA, 20)
pc3_ranked_list <- read.table("data/pc3rank.rnk", header = T, stringsAsFactors = F)
head(pc3_ranked_list)
prepare_ranked_list <- function(ranked_list) {
if( sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(.~Gene.name, FUN = mean, data = ranked_list)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = T),]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list)
ranked_list
}
pc3_ranked_list <- prepare_ranked_list(pc3_ranked_list)
head(pc3_ranked_list)
prepare_ranked_list <- function(ranked_list) {
if (is.vector(ranked_list) && !is.list(ranked_list)) {
return(ranked_list)  # Return as-is if already processed
}
if (!is.data.frame(ranked_list)) {
stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
}
if (sum(duplicated(ranked_list$Gene.name)) > 0) {
ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
}
ranked_list <- na.omit(ranked_list)
ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])
return(ranked_list)
}
if (!exists("pc3_ranked_list")) {
symbol_map <- bitr(res_pc3$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
rank_df_pc3 <- merge(res_pc3, symbol_map, by.x = "ENSEMBL", by.y = "ENSEMBL")
rank_df_pc3 <- rank_df_pc3[, c("SYMBOL", "log2FoldChange")]
colnames(rank_df_pc3) <- c("Gene.name", "log2FoldChange")
pc3_ranked_list <- rank_df_pc3
# Example: Convert res_lncap to a ranked list data frame
}
pc3_ranked_list <- prepare_ranked_list(pc3_ranked_list)
print(head(pc3_ranked_list))
fgsea_results <- fgsea(pathways = hallmark_pathway,
stats = pc3_ranked_list,
minSize = 15,
maxSize = 500,
nperm= 1000)
fgsea_results_ordered <- fgsea_results[order(-NES)]
head(fgsea_results_ordered[, .(pathway, padj, NES)])
waterfall_plot <- function (fsgea_results, graph_title) {
fgsea_results %>%
mutate(short_name = str_split_fixed(pathway, "_",2)[,2])%>% # removes 'HALLMARK_' from the pathway title
ggplot( aes(reorder(short_name,NES), NES)) +
geom_bar(stat= "identity", aes(fill = padj<0.05))+
coord_flip()+
labs(x = "Hallmark Pathway", y = "Normalized Enrichment Score", title = graph_title)+
theme(axis.text.y = element_text(size = 7),
plot.title = element_text(hjust = 1))
}
library(stringr)
hallmark_enrich <- waterfall_plot(fgsea_results, "Hallmark pathways altered by hypoxia in PC3 cells")
ggsave("results/hallmark_enrich_pc3.png",
plot = hallmark_enrich,
bg = "white",
width = 10, height = 10, dpi = 300)
write.csv(my_colData,file = "data/metadata")
my_colData <- as.data.frame(condition)
rownames(my_colData) <- colnames(raw_counts)
write.csv(my_colData,file = "data/metadata")
write.csv(my_colData,file = "data/metadata.csv")
sink("sessio_imfo.txt")
sessioninfo()
sink("sessio_imfo.txt")
sessioninfo::session_info()
sink()
sink("session_info.txt")
sessionInfo()
sink()
